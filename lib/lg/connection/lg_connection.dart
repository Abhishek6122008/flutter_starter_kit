// SKELETON: Liquid Galaxy connection & control contract.
//
// This file intentionally contains NO real networking, SSH,
// file system access or command execution.
//
// All real implementations must be generated and injected
// by Antigravity + Gemini agent workflows.

import '../../kmls/common_kml.dart';

/// Holds LG connection configuration.
///
/// SKELETON DATA MODEL
class LGConfig {
  final String ip;
  final int port;
  final String username;
  final String password;

  const LGConfig({
    required this.ip,
    required this.port,
    required this.username,
    required this.password,
  });
}

/// Main Liquid Galaxy control surface for the starter kit.
///
/// This is a stable contract used by:
/// - presentation layer
/// - agent workflows
/// - generated demo apps
///
/// No platform, SSH or shell logic is allowed here.
class LGConnection {
  final LGConfig config;

  LGConnection(this.config);

  // ---------------- STATE (SKELETON) ----------------

  bool get isConnected => false;
  bool get isOrbitPlaying => false;

  double? currentLat;
  double? currentLon;
  double? currentZoom;

  // ---------------- CONNECTION ----------------

  /// SKELETON HOOK
  ///
  /// Agent workflow must generate:
  /// - connection validation
  /// - handshake logic
  /// - remote capability checks
  Future<bool> connect() async {
    throw UnimplementedError(
      'LGConnection.connect() must be generated by an agent workflow.',
    );
  }

  /// SKELETON HOOK
  Future<void> disconnect() async {
    throw UnimplementedError(
      'LGConnection.disconnect() must be generated by an agent workflow.',
    );
  }

  // ---------------- KML CONTROL ----------------

  /// SKELETON HOOK
  ///
  /// Sends a raw KML string to the LG cluster.
  Future<void> sendKml(
    String fileName,
    String kmlContent,
  ) async {
    throw UnimplementedError(
      'LGConnection.sendKml() must be generated by an agent workflow.',
    );
  }

  /// SKELETON HOOK
  ///
  /// Sends a structured payload to LG and updates camera.
  Future<void> showKml(
    String fileName,
    KmlPayload payload,
  ) async {
    throw UnimplementedError(
      'LGConnection.showKml() must be generated by an agent workflow.',
    );
  }

  /// SKELETON HOOK
  ///
  /// Low-level API support for agent workflows.
  Future<void> showRawKml({
    required String fileName,
    required String kml,
  }) async {
    throw UnimplementedError(
      'LGConnection.showRawKml() must be generated by an agent workflow.',
    );
  }

  /// SKELETON HOOK
  Future<void> cleanKmls() async {
    throw UnimplementedError(
      'LGConnection.cleanKmls() must be generated by an agent workflow.',
    );
  }

  // ---------------- CAMERA CONTROL ----------------

  /// SKELETON HOOK
  Future<void> flyTo({
    required double lat,
    required double lon,
    required double range,
  }) async {
    throw UnimplementedError(
      'LGConnection.flyTo() must be generated by an agent workflow.',
    );
  }

  /// SKELETON STATE HELPER
  void setCurrentTarget({
    required double lat,
    required double lon,
    required double zoom,
  }) {
    currentLat = lat;
    currentLon = lon;
    currentZoom = zoom;
  }

  // ---------------- MOVEMENT / NAVIGATION ----------------

  Future<void> moveUp() async {
    throw UnimplementedError(
      'LGConnection.moveUp() must be generated by an agent workflow.',
    );
  }

  Future<void> moveDown() async {
    throw UnimplementedError(
      'LGConnection.moveDown() must be generated by an agent workflow.',
    );
  }

  Future<void> moveLeft() async {
    throw UnimplementedError(
      'LGConnection.moveLeft() must be generated by an agent workflow.',
    );
  }

  Future<void> moveRight() async {
    throw UnimplementedError(
      'LGConnection.moveRight() must be generated by an agent workflow.',
    );
  }

  Future<void> rotateLeft() async {
    throw UnimplementedError(
      'LGConnection.rotateLeft() must be generated by an agent workflow.',
    );
  }

  Future<void> rotateRight() async {
    throw UnimplementedError(
      'LGConnection.rotateRight() must be generated by an agent workflow.',
    );
  }

  // ---------------- LOGO / OVERLAY ----------------

  Future<void> sendLogo(
    int screen,
    String kmlContent,
  ) async {
    throw UnimplementedError(
      'LGConnection.sendLogo() must be generated by an agent workflow.',
    );
  }

  Future<void> cleanLogo(
    int screen,
  ) async {
    throw UnimplementedError(
      'LGConnection.cleanLogo() must be generated by an agent workflow.',
    );
  }

  // ---------------- ORBIT SYSTEM ----------------

  /// UI toggle helper.
  Future<void> toggleOrbit({
    required double latitude,
    required double longitude,
    required double zoom,
    required double tilt,
  }) async {
    throw UnimplementedError(
      'LGConnection.toggleOrbit() must be generated by an agent workflow.',
    );
  }

  /// Generates an orbit LookAt snippet.
  ///
  /// SKELETON:
  /// Agent workflows may override this strategy.
  String orbitLookAtLinear(
    double latitude,
    double longitude,
    double zoom,
    double tilt,
    double bearing,
  ) {
    throw UnimplementedError(
      'LGConnection.orbitLookAtLinear() must be generated by an agent workflow.',
    );
  }

  Future<void> flyToOrbit(
    double latitude,
    double longitude,
    double zoom,
    double tilt,
    double bearing,
  ) async {
    throw UnimplementedError(
      'LGConnection.flyToOrbit() must be generated by an agent workflow.',
    );
  }

  Future<bool> orbitPlay(
    double latitude,
    double longitude,
    double zoom,
    double tilt,
  ) async {
    throw UnimplementedError(
      'LGConnection.orbitPlay() must be generated by an agent workflow.',
    );
  }

  Future<void> orbitStop() async {
    throw UnimplementedError(
      'LGConnection.orbitStop() must be generated by an agent workflow.',
    );
  }
}
